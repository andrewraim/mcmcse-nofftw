---
title: "ess_wrapper"
author: "Kushagra Gupta"
date: "6/25/2021"
output: html_document
---

```{r, results=FALSE, warning=FALSE, message=FALSE}
set.seed(10)
library(mcmcse)
library(MCMCpack)
library(Rcpp)
library(rbenchmark)
source("../optimal_bs_egs/var1_function.R")
sourceCpp('../ess_cpp.cpp')
source("batchsize_final.R")
```

```{r}
# ESS without symmetric=TRUE but the numerically stable e^log(eigen values)

### change covmat <- mcse.multi(chain, size = bs, ...)$cov to covmat <- mcse.multi(chain, ...)$cov
multiESS_no_sym_log <- function(x, covmat = NULL, g = NULL, ...) {
  chain <- as.matrix(x)
	if(!is.matrix(x) && !is.data.frame(x))
	  stop("'x' must be a matrix or data frame.")

	if (is.function(g)) 
	{
	  chain <- apply(x, 1, g)

	  if(is.vector(chain))
	  {
	    chain <- as.matrix(chain)
	  }else
	  {
	    chain <- t(chain)
	  }
	}
	## Setting dimensions on the mcmc output. 
	n = dim(chain)[1]
	p = dim(chain)[2]

	if(!is.matrix(covmat))
	{
	  bs = batchSize_final(chain, fast = FALSE)
	  covmat <- mcse.multi(chain, size = bs, ...)$cov
	} 
	
	var_mat <- cov(chain)
	log.det.var.p <- sum(log(eigen(var_mat, only.values = TRUE)$values))
	log.det.covmat.p <- sum(log(eigen(covmat, only.values = TRUE)$values))
	ess <- n*exp((log.det.var.p - log.det.covmat.p)/p)
return(ess)
}
```


```{r}
# # ESS with symmetric=TRUE but the numerically stable e^log(eigen values)
multiESS_eigen_log <- function(x, covmat = NULL, g = NULL, ...) {
  chain <- as.matrix(x)
	if(!is.matrix(x) && !is.data.frame(x))
	  stop("'x' must be a matrix or data frame.")

	if (is.function(g)) 
	{
	  chain <- apply(x, 1, g)

	  if(is.vector(chain))
	  {
	    chain <- as.matrix(chain)
	  }else
	  {
	    chain <- t(chain)
	  }
	}
	## Setting dimensions on the mcmc output. 
	n = dim(chain)[1]
	p = dim(chain)[2]

	if(!is.matrix(covmat))
	{
	  bs = batchSize_final(chain, fast = FALSE)
	  covmat <- mcse.multi(chain, size = bs, ...)$cov
	} 
	
	var_mat <- cov(chain)
	log.det.var.p <- sum(log(eigen(var_mat, symmetric = TRUE, only.values = TRUE)$values))
	log.det.covmat.p <- sum(log(eigen(covmat, symmetric = TRUE, only.values = TRUE)$values))
	ess <- n*exp((log.det.var.p - log.det.covmat.p)/p)
return(ess)
}
```

```{r}
# # ESS with symmetric=TRUE 
multiESS_eigen_symmetric <- function(x, covmat = NULL, g = NULL, ...)
{

	chain <- as.matrix(x)
	if(!is.matrix(x) && !is.data.frame(x))
	  stop("'x' must be a matrix or data frame.")

	if (is.function(g)) 
	{
	  chain <- apply(x, 1, g)

	  if(is.vector(chain))
	  {
	    chain <- as.matrix(chain)
	  }else
	  {
	    chain <- t(chain)
	  }
	}
	## Setting dimensions on the mcmc output. 
	n = dim(chain)[1]
	p = dim(chain)[2]

	if(!is.matrix(covmat))
	{
	  bs = batchSize_final(chain, fast = FALSE)
	  covmat <- mcse.multi(chain, size = bs, ...)$cov
		
	} 
	
	var_mat <- cov(chain)
  det.var.p <- prod(eigen(var_mat, symmetric = TRUE, only.values = TRUE)$values^(1/p))
  det.covmat.p <- prod(eigen(covmat, symmetric = TRUE, only.values = TRUE)$values^(1/p))
  ess <- n*(det.var.p/det.covmat.p)
return(ess)

}
```

```{r}
# cpp calculation for ess estimation with the numerically stable e^log(eigen values)
multiESS_new <- function(x, covmat = NULL, g = NULL, ...)
{

	chain <- as.matrix(x)
	if(!is.matrix(x) && !is.data.frame(x))
	  stop("'x' must be a matrix or data frame.")

	if (is.function(g)) 
	{
	  chain <- apply(x, 1, g)

	  if(is.vector(chain))
	  {
	    chain <- as.matrix(chain)
	  }else
	  {
	    chain <- t(chain)
	  }
	}


	if(!is.matrix(covmat))
	{
		bs = batchSize_final(chain)
	  covmat <- mcse.multi(chain, size = bs, ...)$cov
	} 
	ess = multiESS_cpp(chain, covmat)
return(ess)
}
```

```{r}
var_fit_truth <- function(phi,omega)
{

  p <- dim(phi)[2]
  Inv.IPhi <- qr.solve(diag(1,p) - phi)
  V <- matrix(qr.solve(diag(1, p^2) - kronecker(phi, phi))%*%as.numeric(omega), nrow = p, ncol = p)
  Sigma <- Inv.IPhi%*%V + V%*%t(Inv.IPhi) - V
  Gamma <- - ( Inv.IPhi %*% Inv.IPhi %*% phi %*% V + V %*% t(phi) %*% t(Inv.IPhi) %*% t(Inv.IPhi) )
  return(list(Sigma = Sigma, Gamma = Gamma))
}

p <- 20
N <- 1e4

A <- matrix(rnorm(p^2), ncol = p, nrow = p)
B <-  A %*% t(A)
Phi0 <- B/(max(eigen(B)$values) + .001)
phi <- 0.9 * Phi0
omega <- diag(p)
var_truth <- var_fit_truth(phi = phi, omega = omega)
const_truth = (sum(diag(var_truth$Gamma)^2)/(sum(diag(var_truth$Sigma)^2)))^(1/3)

```

```{r}
make_VAR <- function(p, N)  {

  A <- matrix(rnorm(p^2), ncol = p, nrow = p)
  B <-  A %*% t(A)
  Phi0 <- B/(max(eigen(B)$values) + .001)
  phi <- 0.9 * Phi0
  omega <- diag(p)
  var_truth <- var_fit_truth(phi = phi, omega = omega)
  const_truth = (sum(diag(var_truth$Gamma)^2)/(sum(diag(var_truth$Sigma)^2)))^(1/3)
  chain <-  var1(p = p, phi = phi, nsim = N, omega = omega)
  return(chain)
}
```

```{r, cache=TRUE}
#set.seed(10)
chain = make_VAR(20, 1e4)
bs = batchSize_final(chain)
covmat = mcse.multi(chain, size = bs)$cov
print(multiESS(chain, r = 1))
print(multiESS_eigen_log(chain, r=1))

benchmark(replications = 10, multiESS(chain, covmat = covmat, r = 1), multiESS_new(chain, covmat = covmat, r = 1), multiESS_eigen_log(chain, covmat = covmat, r = 1), multiESS_eigen_symmetric(chain, covmat = covmat, r = 1), multiESS_no_sym_log(chain, covmat = covmat, r = 1))

chain = make_VAR(50, 1e4)
bs = batchSize_final(chain)
covmat <- mcse.multi(chain, size = bs)$cov
print(multiESS(chain, r = 1))
print(multiESS_eigen_log(chain, r=1))

benchmark(replications = 10, multiESS(chain, covmat = covmat, r = 1), multiESS_new(chain, covmat = covmat, r = 1), multiESS_eigen_log(chain, covmat = covmat, r = 1), multiESS_eigen_symmetric(chain, covmat = covmat, r = 1), multiESS_no_sym_log(chain, covmat = covmat, r = 1))

chain = make_VAR(75, 1e4)
bs = batchSize_final(chain)
covmat  <- mcse.multi(chain, size = bs)$cov
print(multiESS(chain, r = 1))
print(multiESS_eigen_log(chain, r=1))

benchmark(replications = 10, multiESS(chain, covmat = covmat, r = 1), multiESS_new(chain, covmat = covmat, r = 1), multiESS_eigen_log(chain, covmat = covmat, r = 1), multiESS_eigen_symmetric(chain, covmat = covmat, r = 1), multiESS_no_sym_log(chain, covmat = covmat, r = 1))

```

```{r, cache = TRUE}
chain = matrix(rnorm(5e6), nrow = 1e4, ncol = 500)
bs = batchSize_final(chain)
covmat  <- mcse.multi(chain, size = bs)$cov
print(multiESS(chain, r = 1))
print(multiESS_eigen_log(chain, r=1))

benchmark(replications = 100, multiESS(chain, covmat = covmat, r = 1), multiESS_new(chain, covmat = covmat, r = 1), multiESS_eigen_log(chain, covmat = covmat, r = 1), multiESS_eigen_symmetric(chain, covmat = covmat, r = 1), multiESS_no_sym_log(chain, covmat = covmat, r = 1))
```


Using e^(sum(log(eigen values))) improves the stability of the estimates but doesn't give any advantage in terms of speed. One thing of note is the difference in the ESS estimate using the old and new batchsize function. Minor difference in batchsize is resulting in a reasonably large difference in ESS estimate. This has largely to do with the fact that adjust_matrix() is being called for the old batchsize and not for the new one. Therefore, the covariance estimate is significantly different for the two methods. Possible solutions to this is to modify the adjust_matrix() function or to use only p-1 eigen values. 


