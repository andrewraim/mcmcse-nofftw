---
title: "batchsize_constant_compare"
author: "Kushagra Gupta"
date: "6/21/2021"
output:
  html_document: default
---
```{r, results=FALSE, warning=FALSE, message=FALSE, echo = FALSE}
library(MCMCpack)
library(Rcpp)
library(rbenchmark)
source("optimal_bs_egs/eel_data.R")
source("optimal_bs_egs/spatio_temp_function.R")
source("optimal_bs_egs/var1_function.R")
sourceCpp('batchsize_const.cpp')
```

### Adding a threshold
The Levinson algorithm used for calculating the AR coefficients in stats package of R runs recursively, i.e. it uses coefficients obtained from fitting AR(p-1) to obtain coefficients from fitting AR(p). The current fortran implementation  estimates coefficients for fitting AR(p) for p = 1 to order.max, irrespective of the value of aic parameter to ar(). We have added a check in our implementation which compares the coefficient to a threshold. If at any time a coefficient falls below the threshold, we don’t compute coefficients beyond that order (i.e. we don’t always complete the loop from 1 to order.max) and return. Therefore, we have added a threshold check in the Levinson algorithm which can stop the recurssion going from 1 to order.max if at any time any estimated coefficient falls below the threshold.

### Calculating acf
THe Levinson algorithm requires acf of the components of the Markov chain. We explore the option of using just the last 1e4 or 5e4 samples of the chain for calculating the acf in order to speed up the overall function.

### Functions compared

```{r, warning=FALSE, message=FALSE, echo = FALSE}
library(kableExtra)

func_table = data.frame(functions = c("batchSize_const()", "batchSize_threshold_cpp_const()", "batchSize_threshold_cpp_last_const(last_size = 1e4)", "batchSize_threshold_cpp_last_const(last_size = 5e4)"),
                        description = c(
                          "Original batchsize function currently implemented in the package, modified to return the coefficient rather than the batchsize.",
                          "cpp implementation of batchsize with a threshold (used for confidence interval by plot.acf). If estimated coefficients fall below the threshold while iterating from order = 1:order.max, the method uses order-1 as the order of the AR process.",
                          "cpp implementation with threshold which uses min(N, last_size=1e4) samples from the end of the Markov chain to calculate acf",
                          "cpp implementation with threshold which uses min(N, last_size=5e4) samples from the end of the Markov chain to calculate acf"
                        ))

kbl(func_table) %>%
  kable_styling(bootstrap_options = "striped", font_size = 17) %>%
  kable_paper(full_width = T) %>%
  column_spec(1, bold = T, border_right = T) %>%
  column_spec(2, width = "90em")
```


```{r, echo = FALSE}
arp_approx <- function(x)
{
  
  # Fitting a univariate AR(m) model
  ar.fit <- ar(x, aic = TRUE)

  # estimated autocovariances
  gammas <- as.numeric(acf(x, type = "covariance", lag.max = ar.fit$order, plot = FALSE)$acf)
  spec <- ar.fit$var.pred/(1-sum(ar.fit$ar))^2  #asym variance
  
  if(ar.fit$order != 0)
  {
  foo <- 0
  for(i in 1:ar.fit$order)
  {
    for(k in 1:i)
    {
      foo <- foo + ar.fit$ar[i]*k*gammas[abs(k-i)+1]
    }
  }
  Gamma <- 2*(foo + (spec - gammas[1])/2 *sum(1:ar.fit$order * ar.fit$ar)  )/(1-sum(ar.fit$ar))
  } else{
    Gamma <- 0
  }
  rtn <- cbind(Gamma, spec)
  colnames(rtn) <- c("Gamma", "Sigma")
  return(rtn)
}


batchSize_const <- function(x, method = "bm", g = NULL)
{

  chain <- as.matrix(x)
  if(!is.matrix(chain) && !is.data.frame(chain))
    stop("'x' must be a matrix or data frame.")

  if (is.function(g)) 
  {
    chain <- apply(chain, 1, g)

    if(is.vector(chain))
    {
      chain <- as.matrix(chain)
    }else
    {
      chain <- t(chain)
    }
  }

  n <- dim(chain)[1]
  ar_fit <- apply(chain, 2, arp_approx)^2
  coeff <- ( sum(ar_fit[1,])/sum(ar_fit[2,]) )^(1/3)

  b.const <- (3/2*n)*(method == "obm" || method == "bartlett" || method == "tukey") + (n)*(method == "bm")
  b <- b.const^(1/3) * coeff
  if(b <= 1) b <- 1

  b <- floor(b)
  return(coeff)
}
```

```{r, echo = FALSE}
batchSize_threshold_cpp_const <- function(x, method = "bm", g = NULL) {

  if(!is.numeric(x))
    stop("'x' must be numeric")
  if(any(is.na(x)))
    stop("NAs found")
  p <- ncol(x)
  n <- sum(!is.na(x[,1])) # number of non-missing rows
  chain <- as.matrix(x)
  if(!is.matrix(chain) && !is.data.frame(chain))
    stop("'x' must be a matrix or data frame.")

  if (is.function(g)) 
  {
    chain <- apply(chain, 1, g)

    if(is.vector(chain))
    {
      chain <- as.matrix(chain)
    }else
    {
      chain <- t(chain)
    }
  }
  order.max <- min(p, n - 1L, floor(10 * log10(n))) 
  xacf = sapply(1:p, function(i) acf(chain[,i], type = "covariance", lag.max = order.max, plot = FALSE,
                                       demean=TRUE, na.action = na.pass)$acf)

  threshold = qnorm((1.95)/2)/sqrt(n)
  b = batchsize_cpp(n, p, xacf, order.max, method, threshold)
  return(b)
}
```


```{r, echo = FALSE}
batchSize_threshold_cpp_last_const <- function(x, method = "bm", g = NULL, last_size = 1e4) {

  if(!is.numeric(x))
    stop("'x' must be numeric")
  if(any(is.na(x)))
    stop("NAs found")
  p <- ncol(x)
  n <- sum(!is.na(x[,1])) # number of non-missing rows
  chain <- as.matrix(x)
  if(!is.matrix(chain) && !is.data.frame(chain))
    stop("'x' must be a matrix or data frame.")

  if (is.function(g)) 
  {
    chain <- apply(chain, 1, g)

    if(is.vector(chain))
    {
      chain <- as.matrix(chain)
    }else
    {
      chain <- t(chain)
    }
  }
  order.max <- min(p, n - 1L, floor(10 * log10(n))) 
  xacf = matrix(, nrow = order.max+1, ncol = p)
  last = min(n, last_size)
  chain2 = chain[(n-last+1):n,]
  xacf = sapply(1:p, function(i) acf(chain2[,i], type = "covariance", lag.max = order.max, plot = FALSE,
                                       demean=TRUE, na.action = na.pass)$acf)

  threshold = qnorm((1.95)/2)/sqrt(n)
  b = batchsize_cpp(n, p, xacf, order.max, method, threshold)
  return(b)
}

```

## Simulation study of examples in the paper 'Batch size selection for variance estimators in MCMC'

We compare the boxplots of 1e2 estimates of the coefficient = $\left( \frac{\sum_{i=1}^{p} \Gamma_{ii}^{2}}{\sum_{i=1}^{p} \Sigma_{ii}^{2}} \right)^{1/3}$ of the optimal batch size, as defined in the paper. We also compare the run times of each function after comparing the boxplots.


### VAR 1 process


```{r VAR1, cache=TRUE, results = FALSE}
var_fit_truth <- function(phi,omega)
{

  p <- dim(phi)[2]
  Inv.IPhi <- qr.solve(diag(1,p) - phi)
  V <- matrix(qr.solve(diag(1, p^2) - kronecker(phi, phi))%*%as.numeric(omega), nrow = p, ncol = p)
  Sigma <- Inv.IPhi%*%V + V%*%t(Inv.IPhi) - V
  Gamma <- - ( Inv.IPhi %*% Inv.IPhi %*% phi %*% V + V %*% t(phi) %*% t(Inv.IPhi) %*% t(Inv.IPhi) )
  return(list(Sigma = Sigma, Gamma = Gamma))
}

p <- 20
reps <- 1e2
N <- 1e6

A <- matrix(rnorm(p^2), ncol = p, nrow = p)
B <-  A %*% t(A)
Phi0 <- B/(max(eigen(B)$values) + .001)
phi <- 0.9 * Phi0
omega <- diag(p)
var_truth <- var_fit_truth(phi = phi, omega = omega)
const_truth = (sum(diag(var_truth$Gamma)^2)/(sum(diag(var_truth$Sigma)^2)))^(1/3)

OG_bs = numeric(reps)
bs_thresh_cpp = numeric(reps)
bs_thresh_cpp_last_1e4 = numeric(reps)
bs_thresh_cpp_last_5e4 = numeric(reps)

for(i in 1:reps)  {
  if(i %% (reps/10) == 0) print(i)
  chain <-  var1(p = p, phi = phi, nsim = N, omega = omega)
  OG_bs[i] = batchSize_const(chain)
  bs_thresh_cpp[i] = batchSize_threshold_cpp_const(chain)
  bs_thresh_cpp_last_1e4[i] = batchSize_threshold_cpp_last_const(chain, last_size = 1e4)
  bs_thresh_cpp_last_5e4[i] = batchSize_threshold_cpp_last_const(chain, last_size = 5e4)
}


boxplot(OG_bs, bs_thresh_cpp, bs_thresh_cpp_last_1e4, bs_thresh_cpp_last_5e4, names = c("original", "thresh", "thresh last=1e4", "thresh last=5e4"))
abline(h=const_truth)

```


```{r, cache=TRUE}
chain <-  var1(p = p, phi = phi, nsim = N, omega = omega)
benchmark(replications = 10, batchSize_const(chain), batchSize_threshold_cpp_const(chain), batchSize_threshold_cpp_last_const(chain, last_size = 1e4), batchSize_threshold_cpp_last_const(chain, last_size = 5e4), columns = c("test", "replications", "elapsed", "relative"))
```
The cpp implementaion with threshold and last_size = 5e4 is 69 times faster than the original implementation. Additionally, the box plots show that results with last_size = 5e4 are less variable. The Markov chain for this example is 20 dimensional and of size 1e6.

### Spatio Temporal 

```{r spatemp, cache=TRUE, results=FALSE}
N = 1e5
reps = 1e2
OG_bs = numeric(reps)
bs_thresh_cpp = numeric(reps)
bs_thresh_cpp_last_1e4 = numeric(reps)
bs_thresh_cpp_last_5e4 = numeric(reps)

for(i in 1:reps)  {
  if(i %% (reps/10) == 0) print(i)
  chain <- spatio_temp(N = N, verbose = FALSE)
  OG_bs[i] = batchSize_const(chain)
  bs_thresh_cpp[i] = batchSize_threshold_cpp_const(chain)
  bs_thresh_cpp_last_1e4[i] = batchSize_threshold_cpp_last_const(chain, last_size = 1e4)
  bs_thresh_cpp_last_5e4[i] = batchSize_threshold_cpp_last_const(chain, last_size = 5e4)
}


boxplot(OG_bs, bs_thresh_cpp, bs_thresh_cpp_last_1e4, bs_thresh_cpp_last_5e4, names = c("original", "thresh", "thresh last=1e4", "thresh last=5e4"))

```


```{r, cache=TRUE}
chain <- spatio_temp(N = N, verbose = FALSE)
benchmark(replications = 10, batchSize_const(chain), batchSize_threshold_cpp_const(chain), batchSize_threshold_cpp_last_const(chain, last_size = 1e4), batchSize_threshold_cpp_last_const(chain, last_size = 5e4), columns = c("test", "replications", "elapsed", "relative"))
```
The cpp implementaion with threshold and last_size = 5e4 is 38 times faster than the original implementation. Additionally, the box plots show that results with last_size = 5e4 are less variable, although take thrice the amount of time. The Markov chain for this example is 185 dimensional and of size 1e5.

### EEL

```{r eel, cache=TRUE, results=FALSE}
data(Anguilla_train)
N = 1e5
reps = 1e2
random <- sample(1:1e6, reps)

OG_bs = numeric(reps)
bs_thresh_cpp = numeric(reps)
bs_thresh_cpp_last_1e4 = numeric(reps)
bs_thresh_cpp_last_5e4 = numeric(reps)

for(i in 1:reps)  {
  if(i %% (reps/10) == 0) print(i)
  chain <- chain <- MCMClogit(formula = Angaus~ 1 + . , data = dat, seed = random[i], burnin = 0, mcmc = N, thin = 1, B0 = 1/100, tune = .8)
  OG_bs[i] = batchSize_const(chain)
  bs_thresh_cpp[i] = batchSize_threshold_cpp_const(chain)
  bs_thresh_cpp_last_1e4[i] = batchSize_threshold_cpp_last_const(chain, last_size = 1e4)
  bs_thresh_cpp_last_5e4[i] = batchSize_threshold_cpp_last_const(chain, last_size = 5e4)
}


boxplot(OG_bs, bs_thresh_cpp, bs_thresh_cpp_last_1e4, bs_thresh_cpp_last_5e4, names = c("original", "thresh", "thresh last=1e4", "thresh last=5e4"))

```

```{r, cache=TRUE}

chain <- MCMClogit(formula = Angaus~ 1 + . , data = dat, seed = random[1], burnin = 0, mcmc = N, thin = 1, B0 = 1/100, tune = .8)
benchmark(replications = 10, batchSize_const(chain), batchSize_threshold_cpp_const(chain), batchSize_threshold_cpp_last_const(chain, last_size = 1e4), batchSize_threshold_cpp_last_const(chain, last_size = 5e4), columns = c("test", "replications", "elapsed", "relative"))
```
The cpp implementaion with threshold and last_size = 5e4 is 16 times faster than the original implementation. Additionally, the box plots show that results with last_size = 5e4 are less variable, although take twice the amount of time. The Markov chain for this example is 10 dimensional and of size 1e5.  

We find that the cpp implementation with thresholding is significantly faster than the original implementation, and although slightly under-estimates the coefficient, the difference in the estimates is not a lot. Using last_size = 5e4 instead of 1e4 reduces the variability in the estimates without much increase in the computation time, and will be preferred for the future. 

As a final update to the package, we suggest adding a Boolean option fast to the batchSize() function. Setting fast = TRUE will call the cpp implementation with thresholding using the last 5e4 samples for acf calculation. Setting fast = FALSE will call the cpp implementation with thresholding using the entire chain for acf calculation. This update will balance speed with quality, improving remarkably on the existing implementation with only reasonable under-estimation.
