---
title: "adjust_matrix_experiments"
author: "Kushagra Gupta"
date: "7/16/2021"
output: html_document
---

```{r, results=FALSE, warning=FALSE, message=FALSE, echo = FALSE}
set.seed(10)
library(mcmcse)
library(MCMCpack)
library(Rcpp)
library(rbenchmark)
source("optimal_bs_egs/eel_data.R")
source("optimal_bs_egs/spatio_temp_function.R")
source("optimal_bs_egs/var1_function.R")
sourceCpp('ess_cpp.cpp')
source('batchSize_final.R')
```
(a) mcse.multi(r = 1)
(b) mcse.multi(r = 3, adjust = FALSE)
(c) mcse.multi(r = 3, adjust = TRUE)
(d) mcse.multi(r = 1) but replace the diagonals of this with diag( mcse.multi(r = 3, adjust = FALSE) )
      â€” that is calculate regular BM, but replace the diagonals of BM with the diagonals of lugsail.

```{r}
multiESS_eigen_log <- function(x, covmat = NULL, g = NULL, ...) {
  chain <- as.matrix(x)
	if(!is.matrix(x) && !is.data.frame(x))
	  stop("'x' must be a matrix or data frame.")

	if (is.function(g)) 
	{
	  chain <- apply(x, 1, g)

	  if(is.vector(chain))
	  {
	    chain <- as.matrix(chain)
	  }else
	  {
	    chain <- t(chain)
	  }
	}
	## Setting dimensions on the mcmc output. 
	n = dim(chain)[1]
	p = dim(chain)[2]

	if(!is.matrix(covmat))
	{
	  covmat <- mcse.multi(chain,  ...)$cov
	} 
	
	var_mat <- cov(chain)
	log.det.var.p <- sum(log(eigen(var_mat, symmetric = TRUE, only.values = TRUE)$values))
	log.det.covmat.p <- sum(log(eigen(covmat, symmetric = TRUE, only.values = TRUE)$values))
	ess <- n*exp((log.det.var.p - log.det.covmat.p)/p)
return(ess)
}
```

```{r}
multiESS_diag <- function(x, covmat = NULL, g = NULL, ...) {
  chain <- as.matrix(x)
	if(!is.matrix(x) && !is.data.frame(x))
	  stop("'x' must be a matrix or data frame.")

	if (is.function(g)) 
	{
	  chain <- apply(x, 1, g)

	  if(is.vector(chain))
	  {
	    chain <- as.matrix(chain)
	  }else
	  {
	    chain <- t(chain)
	  }
	}
	## Setting dimensions on the mcmc output. 
	n = dim(chain)[1]
	p = dim(chain)[2]

	if(!is.matrix(covmat))
	{
	  covmat <- mcse.multi(chain, r=1, ...)$cov
	  covmat_ls <- mcse.multi(chain, r=3, ...)$cov
	  diag(covmat) = diag(covmat_ls)
	} 
	
	var_mat <- cov(chain)
	log.det.var.p <- sum(log(eigen(var_mat, symmetric = TRUE, only.values = TRUE)$values))
	log.det.covmat.p <- sum(log(eigen(covmat, symmetric = TRUE, only.values = TRUE)$values))
	ess <- n*exp((log.det.var.p - log.det.covmat.p)/p)
  return(ess)
}
```


```{r VAR1, cache=TRUE, warning = FALSE}
var_fit_truth <- function(phi,omega)
{

  p <- dim(phi)[2]
  Inv.IPhi <- qr.solve(diag(1,p) - phi)
  V <- matrix(qr.solve(diag(1, p^2) - kronecker(phi, phi))%*%as.numeric(omega), nrow = p, ncol = p)
  Sigma <- Inv.IPhi%*%V + V%*%t(Inv.IPhi) - V
  Gamma <- - ( Inv.IPhi %*% Inv.IPhi %*% phi %*% V + V %*% t(phi) %*% t(Inv.IPhi) %*% t(Inv.IPhi) )
  return(list(Sigma = Sigma, Gamma = Gamma, Lambda = V))
}

p <- 20
reps <- 1e2
N <- 1e5

A <- matrix(rnorm(p^2), ncol = p, nrow = p)
B <-  A %*% t(A)
Phi0 <- B/(max(eigen(B)$values) + .001)
phi <- 0.9 * Phi0
omega <- diag(p)
var_truth <- var_fit_truth(phi = phi, omega = omega)
ESS_truth = N * (det(var_truth$Lambda)/det(var_truth$Sigma))^(1/p)

ESS_a = numeric(reps)
ESS_b = numeric(reps)
ESS_c = numeric(reps)
ESS_d = numeric(reps)

for(i in 1:reps)  {
  if(i %% (reps/10) == 0) print(i)
  chain <-  var1(p = p, phi = phi, nsim = N, omega = omega)
  bs = batchSize_final(chain, fast = FALSE)
  ESS_a[i] = multiESS_eigen_log(chain, r=1, size = bs)
  ESS_b[i] = multiESS_eigen_log(chain, r=3, adjust = FALSE, size = bs)
  ESS_c[i] = multiESS_eigen_log(chain, r=3, adjust = TRUE, size = bs)
  ESS_d[i] = multiESS_diag(chain, adjust = FALSE, size = bs)
  
}

print(c(sum(is.na(ESS_a)), sum(is.na(ESS_b)), sum(is.na(ESS_c)), sum(is.na(ESS_d))))

boxplot(ESS_a, ESS_b, ESS_c, ESS_d, names = c("ESS_a", "ESS_b", "ESS_c", "ESS_d"))
abline(h = ESS_truth)
```

```{r spatemp, cache=TRUE, warning = FALSE}
N = 1e5
reps = 1e2
ESS_a = numeric(reps)
ESS_b = numeric(reps)
ESS_c = numeric(reps)
ESS_d = numeric(reps)

for(i in 1:reps)  {
  if(i %% (reps/10) == 0) print(i)
  chain <- spatio_temp(N = N, verbose = FALSE)
  ESS_a[i] = multiESS_eigen_log(chain, r=1)
  ESS_b[i] = multiESS_eigen_log(chain, r=3, adjust = FALSE)
  ESS_c[i] = multiESS_eigen_log(chain, r=3, adjust = TRUE)
  ESS_d[i] = multiESS_diag(chain)
}

print(c(sum(is.na(ESS_a)), sum(is.na(ESS_b)), sum(is.na(ESS_c)), sum(is.na(ESS_d))))

boxplot(ESS_a, ESS_b, ESS_c, ESS_d, names = c("ESS_a", "ESS_b", "ESS_c", "ESS_d"))

```

```{r eel, cache=TRUE, warning = FALSE}
data(Anguilla_train)
N = 1e5
reps = 1e2
random <- sample(1:1e6, reps)

ESS_a = numeric(reps)
ESS_b = numeric(reps)
ESS_c = numeric(reps)
ESS_d = numeric(reps)



for(i in 1:reps)  {
  if(i %% (reps/10) == 0) print(i)
  chain <- chain <- MCMClogit(formula = Angaus~ 1 + . , data = dat, seed = random[i], burnin = 0, mcmc = N, thin = 1, B0 = 1/100, tune = .8)
  ESS_a[i] = multiESS_eigen_log(chain, r=1)
  ESS_b[i] = multiESS_eigen_log(chain, r=3, adjust = FALSE)
  ESS_c[i] = multiESS_eigen_log(chain, r=3, adjust = TRUE)
  ESS_d[i] = multiESS_diag(chain)
}

print(c(sum(is.na(ESS_a)), sum(is.na(ESS_b)), sum(is.na(ESS_c)), sum(is.na(ESS_d))))

boxplot(ESS_a, ESS_b, ESS_c, ESS_d, names = c("ESS_a", "ESS_b", "ESS_c", "ESS_d"))

```


